# mathematical-operations
Математика
Одной из основных функций микроконтроллера является выполнение вычислений, как с числами напрямую, так и со значениями переменных. Начнём погружение в мир математики с самых простых действий:

= присваивание
+ сложение
- вычитание
* умножение
/ деление
% остаток от деления
Рассмотрим простой пример:

int a = 10;
int b = 20;
int c = a + b;  // c = 30
int d = a * b;  // d = 200
// так тоже можно
d = d / a;      // d = 20
c = c * d;      // c = 600
По поводу последних двух строчек из примера, когда переменная участвует в расчёте своего собственного значения: существуют также составные операторы, укорачивающие запись:

+= составное сложение: a += 10 равносильно a = a + 10
-= составное вычитание: a -= 10 равносильно a = a - 10
*= составное умножение: a *= 10 равносильно a = a * 10
/= составное деление: a /= 10 равносильно a = a / 10
%= остаток от деления: a %= 10 равносильно a = a % 10
С их использованием можно сократить запись последних двух строчек из предыдущего примера:

d /= a;
c *= d;
Очень часто в программировании используется прибавление или вычитание единицы, для чего тоже есть короткая запись:

++ (плюс плюс) инкремент: a++ равносильно a = a + 1
-- (минус минус) декремент: a-- равносильно a = a - 1
Порядок записи инкремента играет очень большую роль: пост-инкремент var++ возвращает значение переменной до выполнения инкремента. Операция пре-инкремента ++var возвращает значение уже изменённой переменной. Пример:

byte a, b;
a = 10;
b = a++;
// a получит значение 11
// b получит значение 10
a = 10;
b = ++a;
// a получит значение 11
// b получит значение 11
Как говорилось в предыдущем уроке - локальные переменные нужно инициализировать, иначе в математических операциях получится непредсказуемый результат.

{
  byte a;      // просто объявляем
  byte b = 0;  // инициализируем 0
  a++;  // результат непредсказуем
  b++;  // результат 1
}


Целочисленное деление
При целочисленном делении результат не округляется по "математическим" правилам, дробная часть просто отсекается, фактически это округление вниз: и 9/10 и 1/10 дадут 0. При использовании float само собой получится 0.9 и 0.1. Если нужно целочисленное деление с округлением вверх, его можно реализовать так: вместо x / y записать (x + y - 1) / y. Рассмотренные выше примеры деления на 10 дадут результат 1.

Для округления по обычным математическим правилам можно использовать функцию round(), но она довольно тяжёлая, так работает с float.

Переполнение переменной
Вспомним предыдущий урок о типах данных: что будет с переменной, если её значение выйдет из допустимого диапазона? Тут всё весьма просто: при переполнении в бОльшую сторону из нового значения вычитается максимальное значение переменной, и у неё остаётся только остаток. Для сравнения представим переменную как ведро. Будем считать, что при наливании воды и заполнении ведра мы скажем стоп, выльем из него всю воду, а затем дольём остаток. Вот так и с переменной, что останется - то останется. Если переполнение будет несколько раз - несколько раз опорожним наше "ведро" и всё равно оставим остаток. Ещё один хороший пример - кружка Пифагора.

